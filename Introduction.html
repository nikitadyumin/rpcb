<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rx cookbook Introduction</title>
    <link rel="stylesheet" href="main.css">
</head>
<body>
<h1>What is reactive?</h1>
For the purpose of this book let's define <i>reactive programming</i> as programming relying on active producers,
rather than active consumers.

<p>
    Active consumer queries a value from a passive producer (the value should be available):
    <code>
        const value = producer.getValue(); <br>
        console.log(value);
    </code>
    which is a normal function (getter) call.
</p>
<p>
    Passive consumer subscribes to an active producer and waits until the value is available:
    <code>
        producer.subscribe(value => console.log(value));
    </code>
    which is also familiar to us (event listener, callback).
</p>

<img src="images/pull.jpg">
<img src="images/push.jpg">
<h2>Pull vs Push</h2>
Series of values can also be delivered in both pull (passive producer) and push (active producer) manner.
To pull values form a collection we use an Iterator pattern.
(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators):
<pre>
function makeIterator(array){
    var nextIndex = 0;

    return {
       next: function(){
           return nextIndex < array.length ?
               {value: array[nextIndex++], done: false} :
               {done: true};
       }
    }
}
var it = makeIterator(['yo', 'ya']);
console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done);  // true
</pre>
So, values in such collection are available on demand: either upon creation (see the example above) or on request (using generators),
thus can be delivered all at once, synchronously.

To push values from a collection to an observer we use the Observable pattern:
<pre>
function makeObservable(array){
    return {
       subscribe: function(next, complete){
           array.forEach(next);
           complete();
       }
    }
}
var o = makeObservable(['yo', 'ya']);
o.subscribe(
    function onValue(v) {
        console.log(v);
    },
    function onComplete() {
        console.log('done');
    }
);
</pre>
Here onValue function is called every time a new value is available, when no more values are expected onComplete gets called.

<h2>Sync vs Async collections</h2>
Observables <i>can</i> emit values both synchronously and asynchronously providing a unified API:
<pre>
function createObservable(executor) {
    return {
        subscribe: executor
    };
}
var o = createObservable(function(next) {
        next(0);
        next(1);
        next(2);
        setTimeout(next, 100, 3);
        setTimeout(next, 200, 4);
    });
o.subscribe(
    function onValue(v) {
        console.log(v);
    },
    function onComplete() {
        console.log('done');
    }
);
</pre>
First three values are delivered right away (synchronously), the other two after timeout (asynchronously).

<h2>References</h2>
<h3>Videos</h3>
<ul>
    <li><a href="https://www.youtube.com/watch?v=IB4BHRtu2MA"> FluentConf 2016 : Building our reactive future - Matthew
        Podwysocki </a></li>
    <li><a href="https://www.youtube.com/watch?v=sTSQlYX5DU0"> React 2014 : Erik Meijer - What does it mean to be
        Reactive? </a></li>
</ul>
<h3>Reading</h3>
<a href="http://www.sohamkamani.com/blog/2016/03/14/wrapping-your-head-around-async-programming/">async vs sync</a>
</body>
</html>